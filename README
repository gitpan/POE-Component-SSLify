NAME
    POE::Component::SSLify - Makes using SSL in the world of POE easy!

VERSION
      This document describes v1.002 of POE::Component::SSLify - released February 19, 2011 as part of POE-Component-SSLify.

SYNOPSIS
            # CLIENT-side usage

            # Import the module
            use POE::Component::SSLify qw( Client_SSLify );

            # Create a normal SocketFactory wheel and connect to a SSL-enabled server
            my $factory = POE::Wheel::SocketFactory->new;

            # Time passes, SocketFactory gives you a socket when it connects in SuccessEvent
            # Convert the socket into a SSL socket POE can communicate with
            my $socket = shift;
            eval { $socket = Client_SSLify( $socket ) };
            if ( $@ ) {
                    # Unable to SSLify it...
            }

            # Now, hand it off to ReadWrite
            my $rw = POE::Wheel::ReadWrite->new(
                    Handle  =>      $socket,
                    # other options as usual
            );

            # --------------------------------------------------------------------------- #

            # SERVER-side usage

            # !!! Make sure you have a public key + certificate
            # excellent howto: http://www.akadia.com/services/ssh_test_certificate.html

            # Import the module
            use POE::Component::SSLify qw( Server_SSLify SSLify_Options );

            # Set the key + certificate file
            eval { SSLify_Options( 'server.key', 'server.crt' ) };
            if ( $@ ) {
                    # Unable to load key or certificate file...
            }

            # Create a normal SocketFactory wheel to listen for connections
            my $factory = POE::Wheel::SocketFactory->new;

            # Time passes, SocketFactory gives you a socket when it gets a connection in SuccessEvent
            # Convert the socket into a SSL socket POE can communicate with
            my $socket = shift;
            eval { $socket = Server_SSLify( $socket ) };
            if ( $@ ) {
                    # Unable to SSLify it...
            }

            # Now, hand it off to ReadWrite
            my $rw = POE::Wheel::ReadWrite->new(
                    Handle  =>      $socket,
                    # other options as usual
            );

DESCRIPTION
    This component represents the standard way to do SSL in POE.

FUNCTIONS
  Client_SSLify
            Accepts a socket, returns a brand new socket SSLified. Optionally accepts SSL
            context data.
                    my $socket = shift;                                             # get the socket from somewhere
                    $socket = Client_SSLify( $socket );                             # the default
                    $socket = Client_SSLify( $socket, $version, $options );         # sets more options for the context
                    $socket = Client_SSLify( $socket, undef, undef, $ctx );         # pass in a custom context

            If $ctx is defined, SSLify will ignore other args. If $ctx isn't defined, SSLify
            will create it from the $version + $options parameters.

            Known versions:
                    * sslv2
                    * sslv3
                    * tlsv1
                    * default

            By default we use the version: default

            By default we don't set any options

            NOTE: The way to have a client socket with proper certificates set up is:
                    my $socket = shift;     # get the socket from somewhere
                    my $ctx = SSLify_ContextCreate( 'server.key', 'server.crt' );
                    $socket = Client_SSLify( $socket, undef, undef, $ctx );

            BEWARE: If you passed in a CTX, SSLify will do Net::SSLeay::CTX_free( $ctx ) when the
            socket is destroyed. This means you cannot reuse contexts!

  Server_SSLify
            Accepts a socket, returns a brand new socket SSLified
                    my $socket = shift;     # get the socket from somewhere
                    $socket = Server_SSLify( $socket );

            NOTE: SSLify_Options must be set first!

            Furthermore, you can pass in your own $ctx object if you desire. This allows you to set custom parameters
            per-connection, for example.
                    my $socket = shift;     # get the socket from somewhere
                    my $ctx = SSLify_ContextCreate();
                    # set various options on $ctx as desired
                    $socket = Server_SSLify( $socket, $ctx );

            NOTE: You can use SSLify_GetCTX to modify the global, and avoid doing this on every connection if the
            options are the same...

  SSLify_ContextCreate
            Accepts some options, and returns a brand-new Net::SSLeay context object ( $ctx )
                    my $ctx = SSLify_ContextCreate( $key, $cert, $version, $options );

            You can then call various Net::SSLeay methods on the context
                    my $mode = Net::SSLeay::CTX_get_mode( $ctx );

            By default we don't use the SSL key + certificate files

            By default we use the version: default

                    Known versions:
                    * sslv2
                    * sslv3
                    * tlsv1
                    * default

            By default we don't set any options

  SSLify_Options
            Call this function to initialize the global server-side CTX. Accepts the location of the
            SSL key + certificate files, which is required.

            Optionally accepts the SSL version + CTX options
                    SSLify_Options( $key, $cert, $version, $options );

            By default we use the version: default

                    Known versions:
                    * sslv2
                    * sslv3
                    * tlsv1
                    * default

            By default we use the options: &Net::SSLeay::OP_ALL

  SSLify_GetCTX
            Returns the actual Net::SSLeay context object in case you wanted to play with it :)

            If passed in a socket, it will return that socket's $ctx instead of the global.
                    my $ctx = SSLify_GetCTX();                      # get the one set via SSLify_Options
                    my $ctx = SSLify_GetCTX( $sslified_sock );      # get the one in the object

  SSLify_GetCipher
            Returns the cipher used by the SSLified socket

            Example:
                    print "SSL Cipher is: " . SSLify_GetCipher( $sslified_sock ) . "\n";

            NOTE: Doing this immediately after Client_SSLify or Server_SSLify will result in "(NONE)" because the SSL handshake
            is not done yet. The socket is nonblocking, so you will have to wait a little bit for it to get ready.
                    apoc@blackhole:~/mygit/perl-poe-sslify/examples$ perl serverclient.pl
                    got connection from: 127.0.0.1 - commencing Server_SSLify()
                    SSLified: 127.0.0.1 cipher type: ((NONE))
                    Connected to server, commencing Client_SSLify()
                    SSLified the connection to the server
                    Connected to SSL server
                    Input: hola
                    got input from: 127.0.0.1 cipher type: (AES256-SHA) input: 'hola'
                    Got Reply: hola
                    Input: ^C
                    stopped at serverclient.pl line 126.

  SSLify_GetSocket
            Returns the actual socket used by the SSLified socket, useful for stuff like getpeername()/getsockname()

            Example:
                    print "Remote IP is: " . inet_ntoa( ( unpack_sockaddr_in( getpeername( SSLify_GetSocket( $sslified_sock ) ) ) )[1] ) . "\n";

  SSLify_GetSSL
            Returns the actual Net::SSLeay object so you can call methods on it

            Example:
                    print Net::SSLeay::dump_peer_certificate( SSLify_GetSSL( $sslified_sock ) );

NOTES
  Socket methods doesn't work
    The new socket this module gives you actually is some tied socket magic,
    so you cannot do stuff like getpeername() or getsockname(). The only way
    to do it is to use SSLify_GetSocket and then operate on the socket it
    returns.

  Dying everywhere...
    This module will die() if Net::SSLeay could not be loaded or it is not
    the version we want. So, it is recommended that you check for errors and
    not use SSL, like so:

            eval { use POE::Component::SSLify };
            if ( $@ ) {
                    $sslavailable = 0;
            } else {
                    $sslavailable = 1;
            }

            # Make socket SSL!
            if ( $sslavailable ) {
                    eval { $socket = POE::Component::SSLify::Client_SSLify( $socket ) };
                    if ( $@ ) {
                            # Unable to SSLify the socket...
                    }
            }

  OpenSSL functions
    Theoretically you can do anything that Net::SSLeay exports from the
    OpenSSL libs on the socket. However, I have not tested every possible
    function against SSLify, so use them carefully!

   Net::SSLeay::renegotiate
    This function has been tested ( it's in "t/2_renegotiate.t" ) but it
    doesn't work on FreeBSD! I tracked it down to this security advisory:
    <http://security.freebsd.org/advisories/FreeBSD-SA-09:15.ssl.asc> which
    explains it in detail. The test will skip this function if it detects
    that you're on a broken system. However, if you have the updated OpenSSL
    library that fixes this you can use it.

   In-Situ sslification
    You can have a normal plaintext socket, and convert it to SSL anytime.
    Just keep in mind that the client and the server must agree to sslify at
    the same time, or they will be waiting on each other forever! See
    "t/3_insitu.t" for an example of how this works.

EXPORT
            Stuffs all of the above functions in @EXPORT_OK so you have to request them directly

SEE ALSO
    Please see those modules/websites for more information related to this
    module.

    *   POE

    *   Net::SSLeay

SUPPORT
  Perldoc
    You can find documentation for this module with the perldoc command.

      perldoc POE::Component::SSLify

  Websites
    The following websites have more information about this module, and may
    be of help to you. As always, in addition to those websites please use
    your favorite search engine to discover more resources.

    *   Search CPAN

        <http://search.cpan.org/dist/POE-Component-SSLify>

    *   RT: CPAN's Bug Tracker

        <http://rt.cpan.org/NoAuth/Bugs.html?Dist=POE-Component-SSLify>

    *   AnnoCPAN: Annotated CPAN documentation

        <http://annocpan.org/dist/POE-Component-SSLify>

    *   CPAN Ratings

        <http://cpanratings.perl.org/d/POE-Component-SSLify>

    *   CPAN Forum

        <http://cpanforum.com/dist/POE-Component-SSLify>

    *   CPANTS Kwalitee

        <http://cpants.perl.org/dist/overview/POE-Component-SSLify>

    *   CPAN Testers Results

        <http://cpantesters.org/distro/P/POE-Component-SSLify.html>

    *   CPAN Testers Matrix

        <http://matrix.cpantesters.org/?dist=POE-Component-SSLify>

  Email
    You can email the author of this module at "APOCAL at cpan.org" asking
    for help with any problems you have.

  Internet Relay Chat
    You can get live help by using IRC ( Internet Relay Chat ). If you don't
    know what IRC is, please read this excellent guide:
    <http://en.wikipedia.org/wiki/Internet_Relay_Chat>. Please be courteous
    and patient when talking to us, as we might be busy or sleeping! You can
    join those networks/channels and get help:

    *   irc.perl.org

        You can connect to the server at 'irc.perl.org' and join this
        channel: #perl-help then talk to this person for help: Apocalypse.

    *   irc.freenode.net

        You can connect to the server at 'irc.freenode.net' and join this
        channel: #perl then talk to this person for help: Apocal.

    *   irc.efnet.org

        You can connect to the server at 'irc.efnet.org' and join this
        channel: #perl then talk to this person for help: Ap0cal.

  Bugs / Feature Requests
    Please report any bugs or feature requests by email to
    "bug-poe-component-sslify at rt.cpan.org", or through the web interface
    at
    <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=POE-Component-SSLify>.
    You will be automatically notified of any progress on the request by the
    system.

  Source Code
    The code is open to the world, and available for you to hack on. Please
    feel free to browse it and play with it, or whatever. If you want to
    contribute patches, please send me a diff or prod me to pull from your
    repository :)

    <http://github.com/apocalypse/perl-poe-sslify>

      git clone git://github.com/apocalypse/perl-poe-sslify.git

AUTHOR
    Apocalypse <APOCAL@cpan.org>

ACKNOWLEDGEMENTS
            Original code is entirely Rocco Caputo ( Creator of POE ) -> I simply
            packaged up the code into something everyone could use and accepted the burden
            of maintaining it :)

            From the PoCo::Client::HTTP code =]
            # This code should probably become a POE::Kernel method,
            # seeing as it's rather baroque and potentially useful in a number
            # of places.

    ASCENT also helped a lot with the nonblocking mode, without his hard
    work this module would still be stuck in the stone age :)

COPYRIGHT AND LICENSE
    This software is copyright (c) 2011 by Apocalypse.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

    The full text of the license can be found in the LICENSE file included
    with this distribution.

